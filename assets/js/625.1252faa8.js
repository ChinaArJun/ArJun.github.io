(window.webpackJsonp=window.webpackJsonp||[]).push([[625],{1224:function(n,e,o){"use strict";o.r(e);var t=o(44),a=Object(t.a)({},(function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("p",[n._v("https://www.jianshu.com/p/401cfbd77325")]),n._v(" "),o("p",[n._v("Volume的作用\n一切container和它之中的数据都是临时的。如果container重启，这些数据会丢失。Volume用于container保存需要持久化的数据。这些数据也可以用于container共享。")]),n._v(" "),o("p",[n._v("Volume的概念\nDocker中有volume的概念。在Docker中，volume是container中的一个目录。Volume没有生命周期的概念，volume中的数据只有储存在本地磁盘这一种形式。")]),n._v(" "),o("p",[n._v("Kubernetes的volume具有明确的生命空间。Volume生命周期比pod中运行的container长。Container重启之后，volume的数据仍会保留。但是，当Pod销毁之时，该pod关联的volume也会同时销毁。")]),n._v(" "),o("p",[n._v("使用volume的方法：在spec.volumes处声明volume，在spec.containers[*].volumeMount中挂载volume到container。")]),n._v(" "),o("p",[n._v("Volume的类型\nConfigMap\n可以将ConfigMap的值注入到volume中。这样可以在pod中使用config map。同时，Volume中的值会随着ConfigMap的修改而自动更新。")]),n._v(" "),o("p",[n._v("在Volume中使用ConfigMap的用法如下：")]),n._v(" "),o("p",[n._v("apiVersion: v1\nkind: Pod\nmetadata:\nname: configmap-pod\nspec:\ncontainers:\n- name: test\nimage: busybox\nvolumeMounts:\n- name: config-vol\nmountPath: /etc/config\nvolumes:\n- name: config-vol\nconfigMap:\nname: log-config\nitems:\n- key: log_level\npath: log_level\n这里例子将名字为log-config的config map中key为log_level的值，作为文件log_level的内容，放入config-vol的根目录。然后把config-vol挂载到/etc/config，目录。也就是container中/etc/config/log_level文件的内容为log-config中log_level的值。")]),n._v(" "),o("p",[n._v("downwardAPI\n可以使用DownWard API的方式，将k8s资源的spec信息作为文件内容放入到volume中。")]),n._v(" "),o("p",[n._v("例子如下：")]),n._v(" "),o("p",[n._v('apiVersion: v1\nkind: Pod\nmetadata:\nname: kubernetes-downwardapi-volume-example\nlabels:\nzone: us-est-coast\ncluster: test-cluster1\nrack: rack-22\nannotations:\nbuild: two\nbuilder: john-doe\nspec:\ncontainers:\n- name: client-container\nimage: k8s.gcr.io/busybox\ncommand: ["sh", "-c"]\nargs:\n- while true; do\nif [[ -e /etc/podinfo/labels ]]; then\necho -en \'\\n\\n\'; cat /etc/podinfo/labels; fi;\nif [[ -e /etc/podinfo/annotations ]]; then\necho -en \'\\n\\n\'; cat /etc/podinfo/annotations; fi;\nsleep 5;\ndone;\nvolumeMounts:\n- name: podinfo\nmountPath: /etc/podinfo\nvolumes:\n- name: podinfo\ndownwardAPI:\nitems:\n- path: "labels"\nfieldRef:\nfieldPath: metadata.labels\n- path: "annotations"\nfieldRef:\nfieldPath: metadata.annotations\n此处volume使用了downwardAPI。volume中labels文件的内容为pod metadata的labels配置项内容，即：')]),n._v(" "),o("p",[n._v("zone: us-est-coast\ncluster: test-cluster1\nrack: rack-22\nannotation文件的内容为为pod metadata的annotations配置项内容，即：")]),n._v(" "),o("p",[n._v("build: two\nbuilder: john-doe\nemptyDir\n生命周期和pod一样。emptyDir的初始状态为一个没有任何内容的volume。如果Pod从集群节点上移除，那么emptyDir类型的volume中的内容会被清除。")]),n._v(" "),o("p",[n._v("Container遇到崩溃或重启，这时候Pod本身不会受任何影响，这种情况下emptyDir volume中的数据会保留。Container重启之后数据仍然可见。")]),n._v(" "),o("p",[n._v("emptyDir volume具有的这种特性适合如下场景使用：")]),n._v(" "),o("p",[n._v("存放临时文件\n存放检查点，供container崩溃后恢复用\n默认来说emptyDir类型volume的物理存储在硬盘，SSD或网络设备上。可以设置emptyDir.medium为Memory，这时候k8s会使用tempfs（基于内存的文件系统）。此时volume的容量限制收到container的内存配额的制约。")]),n._v(" "),o("p",[n._v("配置样例为：")]),n._v(" "),o("p",[n._v("apiVersion: v1\nkind: Pod\nmetadata:\nname: fortune\nspec:\ncontainers:\n- image: luksa/fortune\nname: html-generator\nvolumeMounts:\n- name: html\nmountPath: /var/htdocs\n- image: nginx:alpine\nname: web-server\nvolumeMounts:\n- name: html\nmountPath: /usr/share/nginx/html\nreadOnly: true\nports:\n- containerPort: 80\nprotocol: TCP\nvolumes:\n- name: html\nemptyDir: {}\n使用tempfs(内存)的emptyDir volume的配置样例如下；")]),n._v(" "),o("p",[n._v("volumes:\n- name: html\nemptyDir:\nmedium: Memory\ngitRepo（已废弃）\ngitRepo比较简单：先准备一个emptyDir类型的volume，再clone一个git repo到volume，然后把volume mount到container。")]),n._v(" "),o("p",[n._v("apiVersion: v1\nkind: Pod\nmetadata:\nname: gitrepo-volume-pod\nspec:\ncontainers:\n- image: nginx:alpine\nname: web-server\nvolumeMounts:\n- name: html\nmountPath: /usr/share/nginx/html\nreadOnly: true\nports:\n- containerPort: 80\nprotocol: TCP\nvolumes:\n- name: html\ngitRepo:\nrepository: https://github.com/luksa/kubia-website-example.git\nrevision: master\ndirectory: .\nhostPath\n此模式挂载pod宿主机文件系统中的文件或目录到pod。")]),n._v(" "),o("p",[n._v("hostPath必须指定一个path参与，用于指定使用宿主机哪个目录。")]),n._v(" "),o("p",[n._v("除此之外还有一个可选的type参数，有如下值可供配置：")]),n._v(" "),o("p",[n._v("(空，什么都不写)：不进行任何检查\nDirectoryOrCreate：如果path对应的目录不存在，自动创建一个目录，权限为0755，所属用户和用户组于kubelet相同。\nDirectory：path对应的目录必须存在。\nFileOrCreate：如果path对应的文件不存在，自动创建一个空文件，权限为0644，所属用户和用户组于kubelet相同。\nFile：path对应的文件必须存在。\nSocket：path必须对应一个unix socket。\nCharDevice：path必须对应一个character device。\nBlockDevice：path必须对应一个block device。\n需要注意的是由于hostPath类型volume的数据和宿主机强绑定，如果pod停止后被schedule到其他节点，pod读取到的数据会有变化。")]),n._v(" "),o("p",[n._v("使用hostPath的例子：")]),n._v(" "),o("p",[n._v("apiVersion: v1\nkind: Pod\nmetadata:\nname: test-pd\nspec:\ncontainers:")]),n._v(" "),o("ul",[o("li",[n._v("image: k8s.gcr.io/test-webserver\nname: test-container\nvolumeMounts:\n"),o("ul",[o("li",[n._v("mountPath: /test-pd\nname: test-volume\nvolumes:")])])]),n._v(" "),o("li",[n._v("name: test-volume\nhostPath:\n"),o("h1",{attrs:{id:"directory-location-on-host"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#directory-location-on-host"}},[n._v("#")]),n._v(" directory location on host")]),n._v("\npath: /data\n"),o("h1",{attrs:{id:"this-field-is-optional"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#this-field-is-optional"}},[n._v("#")]),n._v(" this field is optional")]),n._v("\ntype: Directory\nlocal\nlocal模式支持使用磁盘，分区或者是目录。local还支持使用静态创建的PersistentVolume，不支持Dynamic provisioning(使用PVC的方式)。")])]),n._v(" "),o("p",[n._v("与hostPath不同的是，local模式无需手动配置将pod调度到固定的node上。local模式系统通过volume的node affinity配置来感知volume的node限制（volume只能生成在特定的node上）。")]),n._v(" "),o("p",[n._v("使用例子：")]),n._v(" "),o("p",[n._v("apiVersion: v1\nkind: PersistentVolume\nmetadata:\nname: example-pv\nspec:\ncapacity:\nstorage: 100Gi\nvolumeMode: Filesystem\naccessModes:")]),n._v(" "),o("ul",[o("li",[n._v("ReadWriteOnce\npersistentVolumeReclaimPolicy: Delete\nstorageClassName: local-storage\nlocal:\npath: /mnt/disks/ssd1\nnodeAffinity:\nrequired:\nnodeSelectorTerms:\n"),o("ul",[o("li",[n._v("matchExpressions:\n"),o("ul",[o("li",[n._v("key: kubernetes.io/hostname\noperator: In\nvalues:\n"),o("ul",[o("li",[n._v("example-node\nnodeAffinity必须配置。这个例子创建出的PersistentVolume必须创建在hostname包含example-node的节点上。")])])])])])])])]),n._v(" "),o("p",[n._v("VolumeMode默认值为Filesystem。可以配置为Block，将volume作为块设备使用。")]),n._v(" "),o("p",[n._v("使用local模式的时候建议配套的StorageClass的volumeBindingMode设置为WaitForFirstConsumer。如下所示：")]),n._v(" "),o("p",[n._v("apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\nname: local-storage\nprovisioner: kubernetes.io/no-provisioner\nvolumeBindingMode: WaitForFirstConsumer\n延迟volume绑定可以允许在volume绑定的时候考虑到pod中配置的一些限制，例如node资源限制，node选择器和pod affinity以及pod anti-affinity。")]),n._v(" "),o("p",[n._v("persistentVolumeClaim\n使用PVC声明式的创建所需的PersistentVolume。这个稍后在PersistentVolume中介绍。")]),n._v(" "),o("p",[n._v("projected\n映射多个类型的配置(数据源)到volume中。相当于多种volume合并使用。")]),n._v(" "),o("p",[n._v("可以映射的volume类型为：")]),n._v(" "),o("p",[n._v("secret\ndownwardAPI\nconfigMap\nserviceAccountToken\n所有的volume数据源要求必须和使用它的pod在同一个namespace之下。")]),n._v(" "),o("p",[n._v("一个使用例子如下：")]),n._v(" "),o("p",[n._v("apiVersion: v1\nkind: Pod\nmetadata:\nname: volume-test\nspec:\ncontainers:")]),n._v(" "),o("ul",[o("li",[n._v("name: container-test\nimage: busybox\nvolumeMounts:\n"),o("ul",[o("li",[n._v('name: all-in-one\nmountPath: "/projected-volume"\nreadOnly: true\nvolumes:')])])]),n._v(" "),o("li",[n._v("name: all-in-one\nprojected:\nsources:\n"),o("ul",[o("li",[n._v("secret:\nname: mysecret\nitems:\n- key: username\npath: my-group/my-username")]),n._v(" "),o("li",[n._v('downwardAPI:\nitems:\n- path: "labels"\nfieldRef:\nfieldPath: metadata.labels\n- path: "cpu_limit"\nresourceFieldRef:\ncontainerName: container-test\nresource: limits.cpu')]),n._v(" "),o("li",[n._v("configMap:\nname: myconfigmap\nitems:\n- key: config\npath: my-group/my-config\n使用subPath\n通常我们绑定volume时，映射的是volume的根目录。我们可以通过指定subPath参数，将volume中的其他目录挂载到container中。对于一个pod多个container，且多处使用同一个volume的场景最为适用。")])])])]),n._v(" "),o("p",[n._v("例子如下：")]),n._v(" "),o("p",[n._v('apiVersion: v1\nkind: Pod\nmetadata:\nname: my-lamp-site\nspec:\ncontainers:\n- name: mysql\nimage: mysql\nenv:\n- name: MYSQL_ROOT_PASSWORD\nvalue: "rootpasswd"\nvolumeMounts:\n- mountPath: /var/lib/mysql\nname: site-data\nsubPath: mysql\n- name: php\nimage: php:7.0-apache\nvolumeMounts:\n- mountPath: /var/www/html\nname: site-data\nsubPath: html\nvolumes:\n- name: site-data\npersistentVolumeClaim:\nclaimName: my-lamp-site-data\n这个例子中mysql和php两个container使用同一个volume site-data。Volume的mysql目录映射到了mysql container的/var/lib/mysql。Volume的html目录映射到了php container的/var/www/html。')]),n._v(" "),o("p",[n._v("资源使用\nemptyDir使用磁盘时的限制取决于kubelet所在的文件系统（/var/lib/kubelet）。emptyDir或者hostPath占用多大磁盘空间是没有限制的。")]),n._v(" "),o("p",[n._v("0人点赞\nKubernetes")])])}),[],!1,null,null,null);e.default=a.exports}}]);